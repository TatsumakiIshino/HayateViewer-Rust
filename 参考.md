了解しました。
**`hayro-jpeg2000` クレートから YCbCr データを取り出す際の実務的な注意点**を、
「高速・高画質表示（GPU連携前提）」という観点でまとめます。

---

## 前提整理（重要）

`hayro-jpeg2000` は **pure Rust 実装**で、

* OpenJPEG のような「YCbCr をそのまま吐く API」は **用意されていません**
* 内部では
  **コンポーネント（Component）単位のサンプル配列**
  としてデータを保持します

つまり、

> **「RGB か YCbCr か」を API で選ぶのではなく、
> 自分で Y/Cb/Cr コンポーネントを組み立てる設計**

になります。

---

## 1️⃣ YCbCr は「コンポーネント配列」として取得する

### 基本構造（概念）

```text
Image
 └─ components: Vec<Component>
      ├─ Component 0 → Y
      ├─ Component 1 → Cb
      └─ Component 2 → Cr
```

各 `Component` は：

* 解像度（サブサンプリング済み）
* ビット深度（8 / 10 / 12 / 16）
* サンプル配列（Vec<i32> or Vec<i16>）

---

## 2️⃣ 取得時に見るべき API / フィールド

### 代表的な流れ（概略）

```rust
let image = decoder.decode(&j2k_data)?;
let components = image.components();
```

確認すべきポイント：

| 項目                        | 理由                |
| ------------------------- | ----------------- |
| `components.len()`        | YCbCr か RGB かの判定  |
| `component.precision()`   | bit深度（16bit表示に重要） |
| `component.subsampling()` | 4:2:0 / 4:2:2 対応  |
| `component.samples()`     | 実データ              |

👉 **YCbCr 画像は多くの場合 `components.len() == 3`**

---

## 3️⃣ YCbCr 取得時の最大の落とし穴

### ❗ 落とし穴①：サブサンプリングを無視する

JPEG 2000 では普通にあります：

* 4:4:4
* 4:2:2
* 4:2:0

```text
Y  : 4096x4096
Cb : 2048x2048
Cr : 2048x2048
```

👉 **GPU に渡す前に必ず認識すること**

* Shader 側で補間する
* もしくは CPU 側でアップサンプル

---

### ❗ 落とし穴②：符号付きサンプル

`hayro-jpeg2000` のコンポーネントサンプルは

* **符号付き整数**
* 中心値は 0

つまり：

```text
Y  : [-32768 .. 32767]
Cb : [-32768 .. 32767]
Cr : [-32768 .. 32767]
```

👉 GPU に渡す前に：

* **バイアス補正**
* or Shader 側でオフセット処理

を必ず行う必要があります。

---

## 4️⃣ GPU表示前提なら「生のまま渡す」が正解

### 推奨フロー

```
hayro-jpeg2000
 ↓
YCbCr component planes (signed / 16bit)
 ↓
GPU texture (R16_SNORM など)
 ↓
Shader:
  - オフセット
  - YCbCr → RGB
  - γ / tone
```

❌ CPU で RGB 変換
❌ 8bit 化

これは **高画質路線ではやらない方が良い**です。

---

## 5️⃣ hayro-jpeg2000 特有の注意点（重要）

### 🔹 色変換は「しない」前提で使う

* crate 内の RGB 化ヘルパは **使わない**
* コンポーネント直取得が最短経路

### 🔹 並列化は「タイル外」で

* デコード自体は並列にしづらい
* **取得後の処理（GPU転送など）で並列化**

---

## 6️⃣ OpenJPEG との違い（判断材料）

| 項目        | hayro-jpeg2000 | OpenJPEG |
| --------- | -------------- | -------- |
| Rust純正    | ✅              | ❌        |
| YCbCr直API | ❌              | ✅        |
| 速度        | △              | ◎        |
| 高画質制御     | ○              | ◎        |

👉 **「高画質 × 表示」用途では OpenJPEG の方が有利**
ただし Rust only を貫くなら hayro はアリです。

---

## 7️⃣ 実務向けチェックリスト

* [ ] `components.len() == 3` を確認
* [ ] precision（bit深度）を取得
* [ ] subsampling を確認
* [ ] 符号付きレンジを認識
* [ ] GPU 側で色変換する設計

---

## まとめ（要点だけ）

* `hayro-jpeg2000` は **YCbCr専用APIはない**
* **Component 配列から Y/Cb/Cr を自前で扱う**
* サブサンプリングと符号付き値が最大の注意点
* GPU に「生のまま」渡すのが最速・最高画質

---
